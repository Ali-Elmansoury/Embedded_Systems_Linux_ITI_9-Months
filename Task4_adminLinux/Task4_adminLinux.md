# Linux Administration - Task 4

<p align="center">
    <img src="../Task1_adminLinux/linux_logo.png" width="200" height="150">
</p>

<p align="center">
    <img src="./task4.png">
</p>

## C Program to Demonstrate the Usage of Shared Memory

### Inter-Process Communication (IPC)

**Inter-Process Communication (IPC)** refers to the set of techniques that allow processes to exchange data and signals with one another. IPC is crucial for modern operating systems that support multitasking, as it enables processes to cooperate and share resources effectively. The common IPC mechanisms include:
- Message passing
- Semaphores
- Pipes
- Signals
- **Shared memory**

### What is Shared Memory?

**Shared memory** is a memory segment that multiple processes can access concurrently. It is one of the fastest IPC methods because processes communicate by reading and writing to a shared block of memory. Unlike other IPC mechanisms that involve more complex synchronization and data exchange procedures, shared memory provides a straightforward way for processes to share data.

### How Shared Memory IPC Works

The Shared Memory IPC works by creating a memory segment that is accessible by multiple processes. Here’s a basic outline of how it operates:

1. **Creation of Shared Memory Segment:** A parent process creates a shared memory segment using system calls like `shmget()` in Unix-like systems. This segment is assigned a unique identifier (shmid).
2. **Attaching to the Shared Memory Segment:** Processes attach themselves to the shared memory segment using the `shmat()` system call. Once attached, they can directly read from and write to the shared memory.
3. **Synchronization:** Since multiple processes can access the shared memory simultaneously, synchronization mechanisms like semaphores are often used to prevent race conditions and ensure data consistency.
4. **Detaching and Deleting the Segment:** When a process no longer needs access to the shared memory, it detaches from the segment using the `shmdt()` system call. The shared memory segment can be removed entirely from the system using `shmctl()` once all processes have detached.

### System Calls Used:

<p align="center">
<img src="./image.png">
</p>

Below are the primary system calls used in the shared memory program:

#### 1. **key_t key = ftok("shmfile", 65);**

- **Purpose:** Generates a unique key for creating or accessing the shared memory.

- **ftok Function:**
    - Syntax: `key_t ftok(const char *pathname, int proj_id);`
    - `pathname`: Path to an existing file (e.g., "shmfile").
    - `proj_id`: A project identifier (small integer, here 65).

- **How it Works:**
    - Combines the file's inode and project ID to generate a unique key.
    - If the file does not exist, `ftok` fails and returns -1.

**Why 65 Specifically?**

- There is no strict rule about the value of `proj_id`. The programmer selects it arbitrarily.
- Common practice uses values like 1, 65, 100, or ASCII codes for readable characters:
    - 65 corresponds to the ASCII value of the uppercase letter A.
    - Some developers choose such values to make the code slightly meaningful or easier to remember.

**Characteristics of "shmfile"**

- **Arbitrary Name:** "shmfile" is not a special system file. It is a regular file created by the programmer (it could be named anything, like "keyfile" or "tempfile").
- **Existence is Mandatory:**
    - The file must exist when `ftok` is called. If it doesn’t exist, `ftok` will fail and return -1.
- **Used for Key Generation:**
    - The file's metadata, such as its inode number (a unique identifier for files in the filesystem) and the device ID, are used to produce the key.

#### 2. **int shmid = shmget(key, 1024, 0666 | IPC_CREAT);**

- **Purpose:** Creates or accesses a shared memory segment using the key.

- **shmget Function:**
    - Syntax: `int shmget(key_t key, size_t size, int shmflg);`
    - `key`: Unique key generated by `ftok`.
    - `size`: Size of the shared memory segment (1024 bytes).
    - `shmflg`: Flags for permissions and control:
        - `0666`: Gives read/write permissions to the owner, group, and others.
        - `IPC_CREAT`: Creates the segment if it doesn’t exist.

- **How it Works:**
    - If the segment exists, it returns the shared memory ID.
    - If it doesn’t exist and `IPC_CREAT` is specified, a new segment is created.

#### 3. void *shmat(int shmid, const void *shmaddr, int shmflg);

- **Purpose:** Attaches the shared memory segment to the address space of the calling process.

- **shmat Function:**
    - Syntax: `void *shmat(int shmid, const void *shmaddr, int shmflg);`
    - `shmid`: ID of the shared memory segment.
    - `shmaddr`: Address where the segment is to be attached (NULL for default).
    - `shmflg`: Flags (0 for default behavior).

- **How it Works:**
    - Returns a pointer to the shared memory segment.
    - Once attached, processes can directly read and write to the segment.

#### 4. int shmdt(const void *shmaddr);

- **Purpose:** Detaches the shared memory segment from the process's address space.

- **shmdt Function:**
    - Syntax: `int shmdt(const void *shmaddr);`
    - `shmaddr`: Address of the attached shared memory segment.

- **How it Works:**
    - Removes the shared memory segment from the process's memory space.
    - Other processes can continue to use the segment until it is explicitly deleted.

#### 5. int shmctl(int shmid, int cmd, struct shmid_ds *buf);

- **Purpose:** Controls operations on the shared memory segment (e.g., deleting it).

- **shmctl Function:**
    - Syntax: `int shmctl(int shmid, int cmd, struct shmid_ds *buf);`
    - `shmid`: ID of the shared memory segment.
    - `cmd`: Command to perform (e.g., `IPC_RMID` to delete the segment).
    - `buf`: Pointer to a structure containing control information (optional).

- **How it Works:**
    - `IPC_RMID` removes the shared memory segment.
    - Ensures proper cleanup after all processes are done using the segment.

---

### Writer Code:

```c
#include <stdio.h>  
#include <sys/ipc.h>
#include <sys/shm.h>

#define SHM_SIZE 1024

int main ()
{
    key_t shm_key = ftok("shm_keyFile", 1);
    int shm_id = shmget(shm_key, SHM_SIZE, 0666 | IPC_CREAT);
    char* data = (char*)shmat(shm_id, (void*)0, 0);
    printf("Write data to be shared: ");
    fgets(data, SHM_SIZE, stdin);
    printf("Data written in shared memory: %s\n", data);
    shmdt(data);
    return 0;
}
```

### Reader Code:

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>

#define SHM_SIZE 1024

int main ()
{
    key_t shm_key = ftok("shm_keyFile", 1);
    int shm_id = shmget(shm_key, SHM_SIZE, 0666 | IPC_CREAT);
    char* data = (char*)shmat(shm_id, (void*)0, 0);
    printf("Data written in shared memory: %s\n", data);
    shmdt(data);
    shmctl(shm_id, IPC_RMID, NULL);
    return 0;
}
```

---

### Test:

<img src="./shm_test.png">

---

*Ali Mohamed Ali Elmansoury*  
*ITI Embedded Systems - Intake 45*
